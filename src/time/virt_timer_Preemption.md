Please indicate: [Reprinted from the blog xelatex KVM], and attach a link to this article. Thank you.  
There are some strange features in Intel VT technology that are not used much, and Preemption Timer is one of them. This function is not useful in most situations, but it may have a magical effect in some special situations.
# What is Preemption Timer
Preemption Timer is a mechanism that allows VM to trigger VMEXIT periodically. That is, after the Preemption Timer is set, the virtual machine can generate a VMEXIT after the specified TSC cycle and set the corresponding exit_reason, trap to the VMM. This mechanism is rarely used by developers in the community, and even part of the Linux KVM code does not even have this part of the processing function, but defines related macros (these macros are still used in nested virtualization).  
You need to pay attention to the following two issues when using Preemption Timer:  
Preemption Timer is not accurate in older versions of Intel CPU. In Intel's design, Preemption Timer should be strictly consistent with TSC, but processors before Haswell cannot be strictly consistent.  
The Preemption Timer will only start working when the VCPU enters the Guest (that is, when it enters non-root mode), and its value will not change when the VCPU enters the VMM or when the VCPU is scheduled out of the CPU.  
# How to use Preemption Timer
Preemption Timer has three fields to be set in VMCS:
- **Pin-Based VM-Execution Controls** , Bit 6, " Activate VMX preemption timer": If this bit is set to 1, the Preemption Timer is turned on; if it is 0, the settings of the following two fields are invalid. The corresponding macro of this bit in the Kernel code is **PIN_BASED_VMX_PREEMPTION_TIMER** .  
- VM-Exit Controls , Bit 22, " Save VMX preemption timer value": If this bit is set to 1, the value that has been consumed will be stored in the VMCS every time VMEXIT; if it is set to 0, then every time After VMEXIT, the Preemption Value will be set to the initial value. The corresponding macro of this bit in the Kernel code is **VM_EXIT_SAVE_VMX_PREEMPTION_TIMER** .  
- **VMX-preemption timer value** : This domain is a domain in VMCS, which stores the Preemption Value. This is a 32-bit domain, and the value set is the value at each VMENTER, and it gradually decreases during the running of the VM. If the Save VMXpreemption timer value is set, the field will be updated to the new value when exiting. The difference between the two times can be used to calculate how many TSC cycles the virtual machine runs. The macro used in Kernel is **VMX_PREEMPTION_TIMER_VALUE** .   

For documents related to Preemption Timer, please refer to Intel Manual 3C Volume [1], 25.5.1 and 26.6.4, as well as the relevant content obtained by searching "Preemption Timer" in full text.  
When using, you need to first set the Activate VMX preemption  timer and VMX-preemption timer value. If you need to save the preemption value when VMEXIT is required, you need to set the Save VMX preemption  timer  value so that the preemption value will not be reset when the VM exits for other reasons.  
One possible use environment for Preemption Timer is: it is necessary for the VM to periodically generate VMEXIT, so the above three fields need to be set. **Note: In the VMEXIT generated by Preemption Timer Time-out, it is necessary to reset the VMX preemption timer value.**  
The VMEXIT reason number related to Preemption Timer is 52 , refer to Intel Manual 3C  Table C-1 [1], " VMX-preemption timer expired. The preemption timer counted down to zero".  
# Calculation of Preemption Timer count down frequency
For the calculation of Preemption Timer frequency, please refer to " **25.5.1 VMX-Preemption Timer** " in Intel Manual 3C [1]. Here I will give a simple algorithm. 1. I will clarify the following terms:
- PTTR (Preemption Timer TSC Rate) : In the last five bits of MSR IA32_VMX_MISC, a 5-bit data is stored, which represents the Preemption Timer TSC Rate . The rate indicates how many times the TSC count down will cause the Preemption Timer Value count down once, so I become "Rate".
- PTV (Preemption Timer Value) : the value set in the VMX-preemption timer value field of VMCS
CPI (Cycle Per Instruction) : The CPU cycles consumed by each CPU instruction. The Ideal CPI in the Intel architecture is about 0.25 [2], but it will be larger than this value in general applications. (Note: The reason why CPI is less than 1 is multi-launch and super-pipeline structure).
- IPP (Instructions per Preemption) : How many CPU instructions the VCPU executes from when the Preemption Timer is set to when the relevant VMEXIT is generated.

Here I give a simple calculation method: `IPP = PTV * PTTR/CPI` .  
According to the above formula, the relationship between PTV and IPP can be simply calculated, and the Preemption Timer Value can be determined according to the number of instructions executed in each Preemption.  
Quote:  
[1] http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html  
[2] http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html  
# 通用计时器架构Generic Timer
Generic Timer包含一个系统计数器System Counter 和一组定时器Timer。
1. 系统计数器全局唯一且共享，对所有核心进行广播，频率固定从1MHz到50MHz。一直工作，即使系统处于待机状态或者内核管理仍然工作。位宽56bit到64bit。可通过读取控制寄存器CNTPCT_EL0来获得当前的系统计数值，指令`MRS Xn, CNTPCT_EL0`。系统计数器的频率主要通过控制寄存器CNTFRQ_EL0来控制。频率是可以随意设定的，但只能在EL3下设置，也就是说在系统固件程序里。在其它的异常级别里（EL2到EL0）都不能设置，但是可以通过读取这个CNTFRQ_EL0寄存器来获得在固件中设置好的频率。
2. 每一个核心都由一组定时器，定时器到期通过PPI(private peripheral interrupt)向终端控制器发送中断请求。每组定时器包含最多7个定时器，最少4个。
   1. EL1 physical timer：给操作系统用的物理定时器；
   2. EL1 virtual timer：给操作系统用的虚拟定时器；
   3. Non-secure EL2 physical timer：给虚拟机的宿主系统用的定时器；
   4. EL3 physical timer：给运行于EL3内的固件程序使用的定时器。

# 工作模式
对于Arm定时器来说，总体有两种工作方式：
1. 到一个绝对时间之后就触发；
2. 从现在开始再过一定时间间隔之后触发。
Arm定时器通过两类寄存器来实现以上两种工作方式。一类叫做比较寄存器（CVAL），还有一类叫做定时寄存器（TVAL）。比较寄存器有64位，如果设置了之后，当系统计数器达到或超过了这个值之后（CVAL<系统计数器），就会触发定时器中断。通过这种方式来实现第一类定时任务。定时寄存器有32位，如果设置了之后，会将比较寄存器设置成当前系统计数器加上设置的定时寄存器的值（CVAL=系统计数器+TVAL），后面就一样了，当系统计数器达到或超过了这个值后，就会触发定时中断。通过这种方式来实现第二种定时任务。

可以看出来，无论那种类型的定时器都是单次出发的（One Shot），如果想要周期触发，必须在中断处理程序中重新设置。这也刚好满足Linux系统中对于高精度定时器的要求。

除了设置定时条件的寄存器，其实每组定时器都还有一个控制寄存器（CTL），其只有最低三位有意义，其它的60位全是保留的，设置成0：

# 虚拟化
虚拟计数器 = 物理计数器 - 偏移

偏移的值是通过控制寄存器CNTVOFF_EL2设置的，看名字就知道只能在EL2或EL3层才有权限设置和访问，如果不设置的话，默认值是0，也就是虚拟计数器和物理计数器的值一致。如果想得到虚拟计数器的值，可以通过读取CNTVCT_EL0控制寄存器来获得。